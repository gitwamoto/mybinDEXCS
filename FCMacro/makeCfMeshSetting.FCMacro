#!/usr/bin/env python
# -*- coding: utf-8 -*-
# makeCfMeshSetting.FCMacro
# by Yukiharu Iwamoto
# 2026/1/21 7:27:30 PM

from PySide import QtCore, QtGui
from functools import partial
import os
import shutil
import tempfile
import Mesh
import re
import sys

path_binDEXCS = os.path.expanduser('~/Desktop/binDEXCS2019（解析フォルダを端末で開いてから）') # dakuten.py -j -f <path> で濁点を結合しておく
if path_binDEXCS not in [i.encode('UTF-8') if type(i) is unicode else i
    for i in sys.path] if sys.version_info.major <= 2 else sys.path:
    sys.path.append(path_binDEXCS)
from utilities.dictParse import DictParser
from utilities.dictParse import DictParserList

class FreeCadFileGrid(QtGui.QTableWidget):
    OBJECT_NAME = 0
    TYPE = 1
    CELL_SIZE = 2
    BOUNDARY_LAYER = 3
    N_LAYERS = 4
    RATIO = 5

    COL_LABELS = [
        'OjbectName',
        'Type',
        'CellSize',
        'Boundary\nLayer',
        'nLayers',
        'Ratio/Thickness\nfor SurfaceRefine'
    ]

    def __init__(self, parent, freecad_objects):
        super(FreeCadFileGrid, self).__init__(parent)
        self.table = []
        for obj in freecad_objects:
            try:
                if obj.ViewObject.Visibility and hasattr(obj, 'Shape'):
                    self.table.append([
                        obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label,
                        None,
                        '',
                        False,
                        2,
                        1.2
                    ])
            except:
                print(sys.exc_info())
                pass
        self.setRowCount(len(self.table))
        self.setColumnCount(len(self.table[0]))
        self.setHorizontalHeaderLabels(FreeCadFileGrid.COL_LABELS)
        self.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)
        self.horizontalHeader().setResizeMode(FreeCadFileGrid.OBJECT_NAME, QtGui.QHeaderView.Stretch)
        for i in range(self.rowCount()):
            item = QtGui.QTableWidgetItem(str(self.table[i][FreeCadFileGrid.OBJECT_NAME]))
            item.setFlags(item.flags() & ~QtCore.Qt.ItemIsEditable)
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.setItem(i, FreeCadFileGrid.OBJECT_NAME, item)
            for j in (FreeCadFileGrid.CELL_SIZE, FreeCadFileGrid.N_LAYERS, FreeCadFileGrid.RATIO):
                item = QtGui.QTableWidgetItem(str(self.table[i][j]))
                item.setTextAlignment(QtCore.Qt.AlignRight)
                self.setItem(i, j, item)
            combo = QtGui.QComboBox()
            combo.addItems(['patch', 'wall', 'empty', 'symmetryPlane', 'symmetry', 'overset',
                            'BoxRefine', 'CylinderRefine', 'SphereRefine', 'SurfaceRefine',
                            'BoxSet', 'CylinderSet', 'SphereSet', 'BoxTopo', 'CylinderTopo', 'SphereTopo', 'N/A'])
            self.setCellWidget(i, FreeCadFileGrid.TYPE, combo)
            self.table[i][FreeCadFileGrid.TYPE] = combo.itemText(combo.currentIndex())
            combo.currentIndexChanged.connect(partial(self.actionOnCurrentIndexChanged, i))
            check = QtGui.QCheckBox()
            self.setCellWidget(i, FreeCadFileGrid.BOUNDARY_LAYER, check)
            self.table[i][FreeCadFileGrid.BOUNDARY_LAYER] = check.isChecked()
            check.stateChanged.connect(partial(self.actionOnStateChanged, i))
        self.cellChanged.connect(self.actionOnCellChanged)

    def actionOnCurrentIndexChanged(self, row, index):
        self.updateTable(row, FreeCadFileGrid.TYPE,
            self.cellWidget(row, FreeCadFileGrid.TYPE).itemText(index))

    def actionOnStateChanged(self, row, state):
        try:
            self.updateTable(row, FreeCadFileGrid.BOUNDARY_LAYER, state == QtCore.Qt.Checked.value)
        except:
            self.updateTable(row, FreeCadFileGrid.BOUNDARY_LAYER, state == QtCore.Qt.Checked)

    def actionOnCellChanged(self, row, col):
        try:
            self.updateTable(row, col, self.item(row, col).text())
        except:
            self.item(row, col).setText(str(self.table[row][col]))

    def updateTable(self, row, col, value):
        try:
            if col == FreeCadFileGrid.CELL_SIZE:
                if value == '':
                    self.table[row][col] = value
                else:
                    self.table[row][col] = float(value)
            elif col == FreeCadFileGrid.N_LAYERS:
                self.table[row][col] = int(value)
            elif col == FreeCadFileGrid.RATIO:
                self.table[row][col] = float(value)
            else:
                self.table[row][col] = value
        except:
            raise

    def setCellValue(self, row, col, value):
        try:
            self.updateTable(row, col, value)
            if col == FreeCadFileGrid.TYPE:
                self.cellWidget(row, FreeCadFileGrid.TYPE).setCurrentIndex(
                    self.cellWidget(row, FreeCadFileGrid.TYPE).findText(value))
            elif col == FreeCadFileGrid.BOUNDARY_LAYER:
                self.cellWidget(row, FreeCadFileGrid.BOUNDARY_LAYER).setCheckState(
                    QtCore.Qt.Checked if value else QtCore.Qt.Unchecked)
            else:
                self.item(row, col).setText(value)
        except:
            pass

class MeshFrame(QtGui.QDialog):
    def __init__(self, controller, freecad_objects, case_dir_path, max_cell_size, feature_angle):
        super(MeshFrame, self).__init__(parent = None)
        self.setWindowTitle('cfMesh settings from FreeCAD Model (.fcstd)')

        self.controller = controller

        box_V = QtGui.QVBoxLayout()
        self.setLayout(box_V)

        box_H = QtGui.QHBoxLayout()
        box_V.addLayout(box_H)
        self.caseButton = QtGui.QPushButton('Case directory:')
        self.caseButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.caseButton.clicked.connect(self.controller.actionOnCaseButton)
        box_H.addWidget(self.caseButton)
        self.caseDirST = QtGui.QLabel(case_dir_path)
        box_H.addWidget(self.caseDirST)
        self.openButton = QtGui.QPushButton('xdg-open')
        self.openButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.openButton.clicked.connect(self.controller.actionOnOpenButton)
        box_H.addWidget(self.openButton)

        box_H = QtGui.QHBoxLayout()
        box_V.addLayout(box_H)
        box_H.addWidget(QtGui.QLabel('maxCellSize:'))
        self.maxCellSizeCRL = QtGui.QLineEdit('{:.2f}'.format(max_cell_size))
        self.maxCellSizeCRL.setAlignment(QtCore.Qt.AlignRight)
        self.maxCellSizeCRL.setValidator(QtGui.QDoubleValidator())
        box_H.addWidget(self.maxCellSizeCRL)
        box_H.addItem(QtGui.QSpacerItem(12, 0))
        box_H.addWidget(QtGui.QLabel('minCellSize:'))
        self.minCellSizeCRL = QtGui.QLineEdit()
        self.minCellSizeCRL.setAlignment(QtCore.Qt.AlignRight)
        self.minCellSizeCRL.setValidator(QtGui.QDoubleValidator())
        box_H.addWidget(self.minCellSizeCRL)
        box_H.addItem(QtGui.QSpacerItem(12, 0))
        box_H.addWidget(QtGui.QLabel('featureAngle:'))
        self.featureAngleCRL = QtGui.QLineEdit('{}'.format(feature_angle))
        self.featureAngleCRL.setAlignment(QtCore.Qt.AlignRight)
        self.featureAngleCRL.setValidator(QtGui.QDoubleValidator())
        box_H.addWidget(self.featureAngleCRL)

        self.grid = FreeCadFileGrid(self, freecad_objects)
        box_V.addWidget(self.grid)
        box_V.addWidget(QtGui.QLabel("*** The table above contains all the visible objects.\n" +
            "       Object's visibility can be changed by space key after selection of the object."))

        box_H = QtGui.QHBoxLayout()
        box_V.addLayout(box_H)
        self.exportButton = QtGui.QPushButton('Export')
        self.exportButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.exportButton.clicked.connect(self.controller.actionOnExportButton)
        box_H.addWidget(self.exportButton)
        box_H.addWidget(QtGui.QLabel('->'))
        self.cartesianMeshButton = QtGui.QPushButton('cartesianMesh')
        self.cartesianMeshButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.cartesianMeshButton.clicked.connect(self.controller.actionOnCartesianMeshButton)
        box_H.addWidget(self.cartesianMeshButton)
        box_H.addWidget(QtGui.QLabel('( ->'))
        self.improveMeshQualityButton = QtGui.QPushButton('improveMeshQuality')
        self.improveMeshQualityButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.improveMeshQualityButton.clicked.connect(self.controller.actionOnImproveMeshQualityButton)
        box_H.addWidget(self.improveMeshQualityButton)
        box_H.addWidget(QtGui.QLabel(','))
        self.flattenPatchButton = QtGui.QPushButton('Flatten patch')
        self.flattenPatchButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.flattenPatchButton.clicked.connect(self.controller.actionOnFlattenPatchButton)
        box_H.addWidget(self.flattenPatchButton)
        box_H.addWidget(QtGui.QLabel(')'))
        box_H.addItem(QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum))

        box_H = QtGui.QHBoxLayout()
        box_V.addLayout(box_H)
        self.loadButton = QtGui.QPushButton('Load')
        self.loadButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.loadButton.clicked.connect(self.controller.actionOnLoadButton)
        self.loadButton.setDefault(True)
        box_H.addWidget(self.loadButton)
        self.editButton = QtGui.QPushButton('Edit')
        self.editButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.editButton.clicked.connect(self.controller.actionOnEditButton)
        box_H.addWidget(self.editButton)
        box_H.addItem(QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum))
        self.exitButton = QtGui.QPushButton('Exit')
        self.exitButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.exitButton.clicked.connect(self.actionOnExitButton)
        box_H.addWidget(self.exitButton)

    def setParamsFromDictFiles(self, meshDict_path, setFieldsDict_path, topoSetDict_path):
        try:
            meshDict = DictParser(file_name = meshDict_path)
            assert (meshDict.getValueForKey(['FoamFile', 'class'])[0] == 'dictionary' and
                meshDict.getValueForKey(['FoamFile', 'location'])[0] == '"system"' and
                meshDict.getValueForKey(['FoamFile', 'object'])[0] == 'meshDict')
        except:
            raise Exception(meshDict_path + ' is not a meshDict file.')
        if os.path.isfile(setFieldsDict_path):
            try:
                setFieldsDict = DictParser(file_name = setFieldsDict_path)
                assert (setFieldsDict.getValueForKey(['FoamFile', 'class'])[0] == 'dictionary' and
                    setFieldsDict.getValueForKey(['FoamFile', 'location'])[0] == '"system"' and
                    setFieldsDict.getValueForKey(['FoamFile', 'object'])[0] == 'setFieldsDict')
            except:
                raise Exception(setFieldsDict_path + ' is not a setFieldsDict file.')
        else:
            setFieldsDict = None
        if os.path.isfile(topoSetDict_path):
            try:
                topoSetDict = DictParser(file_name = topoSetDict_path)
                assert (topoSetDict.getValueForKey(['FoamFile', 'class'])[0] == 'dictionary' and
                    topoSetDict.getValueForKey(['FoamFile', 'location'])[0] == '"system"' and
                    topoSetDict.getValueForKey(['FoamFile', 'object'])[0] == 'topoSetDict')
            except:
                raise Exception(topoSetDict_path + ' is not a topoSetDict file.')
        else:
            topoSetDict = None
        try:
            self.maxCellSizeCRL.setText(meshDict.getValueForKey(['maxCellSize'])[0])
        except:
            pass
        try:
            self.minCellSizeCRL.setText(meshDict.getValueForKey(['minCellSize'])[0])
        except:
            pass
        try:
            self.featureAngleCRL.setText(meshDict.getValueForKey(['CUSTOM_OPTIONS', 'featureAngle'])[0])
        except:
            pass
        objects = [i[self.grid.OBJECT_NAME] for i in self.grid.table]
        remainder = objects[:]
        try:
            for x in meshDict.getValueForKey(['renameBoundary', 'newPatchNames']):
                if DictParserList.isType(x, DictParserList.BLOCK) and x.key() in objects:
                    remainder.remove(x.key())
                    for y in x.value():
                        if DictParserList.isType(y, DictParserList.DICT) and y.key() == 'type':
                            self.grid.setCellValue(objects.index(x.key()), self.grid.TYPE, y.value()[0])
        except:
            pass
        try:
            for x in meshDict.getValueForKey(['localRefinement']):
                if DictParserList.isType(x, DictParserList.BLOCK) and x.key() in objects:
                    for y in x.value():
                        if DictParserList.isType(y, DictParserList.DICT) and y.key() == 'cellSize':
                            self.grid.setCellValue(objects.index(x.key()), self.grid.CELL_SIZE, y.value()[0])
        except:
            pass
        try:
            for x in meshDict.getValueForKey(['boundaryLayers', 'patchBoundaryLayers']):
                if DictParserList.isType(x, DictParserList.BLOCK) and x.key() in objects:
                    i = objects.index(x.key())
                    for y in x.value():
                        if not DictParserList.isType(y, DictParserList.DICT):
                            continue
                        if y.key() == 'nLayers':
                            self.grid.setCellValue(i, self.grid.BOUNDARY_LAYER, True)
                            self.grid.setCellValue(i, self.grid.N_LAYERS, y.value()[0])
                        elif y.key() == 'thicknessRatio':
                            self.grid.setCellValue(i, self.grid.RATIO, y.value()[0])
        except:
            pass
        try:
            for x in meshDict.getValueForKey(['objectRefinements']):
                if DictParserList.isType(x, DictParserList.BLOCK) and x.key() in objects:
                    i = objects.index(x.key())
                    remainder.remove(x.key())
                    for y in x.value():
                        if not DictParserList.isType(y, DictParserList.DICT):
                            continue
                        if y.key() == 'cellSize':
                            self.grid.setCellValue(i, self.grid.CELL_SIZE, y.value()[0])
                        elif y.key() == 'type':
                            if y.value()[0] == 'box':
                                self.grid.setCellValue(i, self.grid.TYPE, 'BoxRefine')
                            elif y.value()[0] == 'cone':
                                self.grid.setCellValue(i, self.grid.TYPE, 'CylinderRefine')
                            elif y.value()[0] == 'sphere':
                                self.grid.setCellValue(i, self.grid.TYPE, 'SphereRefine')
        except:
            pass
        try:
            for x in meshDict.getValueForKey(['surfaceMeshRefinement']):
                if DictParserList.isType(x, DictParserList.BLOCK) and x.key() in objects:
                    i = objects.index(x.key())
                    remainder.remove(x.key())
                    for y in x.value():
                        if not DictParserList.isType(y, DictParserList.DICT):
                            continue
                        if y.key() == 'cellSize':
                            self.grid.setCellValue(i, self.grid.CELL_SIZE, y.value()[0])
                            self.grid.setCellValue(i, self.grid.TYPE, 'SurfaceRefine')
                        elif y.key() == 'refinementThickness':
                            self.grid.setCellValue(i, self.grid.RATIO, y.value()[0])
        except:
            pass
        try:
            for x in setFieldsDict.getValueForKey(['regions']):
                for y in x.value():
                    if DictParserList.isType(y, DictParserList.BLOCK) and 'freecad' in y[1].lower():
                        for i, j in enumerate(objects):
                            if j in y[1]:
                                remainder.remove(j)
                                if y.key() == 'boxToCell':
                                    self.grid.setCellValue(i, self.grid.TYPE, 'BoxSet')
                                elif y.key() == 'cylinderToCell':
                                    self.grid.setCellValue(i, self.grid.TYPE, 'CylinderSet')
                                else:
                                    self.grid.setCellValue(i, self.grid.TYPE, 'SphereSet')
                                break
        except:
            pass
        try:
            for x in topoSetDict.getValueForKey(['actions']):
                for y in x.value():
                    grid_index = -1
                    source = None
                    if DictParserList.isType(y, DictParserList.BLOCK):
                        for z in y.value():
                            if DictParserList.isType(z, DictParserList.DICT):
                                if z.key() == 'name':
                                    name = z.value()[0].replace('CellSet', '')
                                    if name in objects:
                                        grid_index = objects.index(name)
                                        remainder.remove(name)
                                elif z.key() == 'source':
                                    if z.value[0] == 'rotatedBoxToCell':
                                        source = 'BoxTopo'
                                    elif z.value[0] == 'cylinderToCell':
                                        source = 'CylinderTopo'
                                    elif z.value[0] == 'sphereToCell':
                                        source = 'SphereTopo'
                                if grid_index != -1 and source is not None:
                                    self.grid.setCellValue(i, self.grid.TYPE, 'BoxTopo')
                                    break
        except:
            pass
        for i in remainder:
            self.grid.setCellValue(objects.index(i), self.grid.TYPE, 'N/A')
        return meshDict, setFieldsDict, topoSetDict

    def actionOnExitButton(self):
        self.close()

class MyController:
    FEATURE_ANGLE = 30
    BASHRC_PATH_4_OPENFOAM = os.path.join(os.sep, 'opt', 'OpenFOAM', 'OpenFOAM-v1906', 'etc', 'bashrc')
    if not os.path.exists(BASHRC_PATH_4_OPENFOAM):
        BASHRC_PATH_4_OPENFOAM = os.path.join(os.sep, 'usr', 'lib', 'openfoam', 'openfoam2106', 'etc', 'bashrc')
    SOLVER_PATH_TEMPLATE = os.path.join(os.sep, 'opt', 'DEXCS', 'template', 'dexcs')

    def __init__(self):
        import FreeCAD
        import Part
        self.doc = App.ActiveDocument
        self.model = MyModel()
        self.meshDict = self.setFieldsDict = self.topoSetDict = None
        if self.doc.FileName == '':
            QtGui.QMessageBox.critical(None, 'Error',
                'This document has never been saved. Save the document and retry.', QtGui.QMessageBox.Close)
            return
        for obj in self.doc.Objects:
            if obj.ViewObject.Visibility and hasattr(obj, 'Shape'):
                obj.Label = obj.Label.strip()
                l = obj.Label
                obj.Label = re.sub('^([0-9])', r'_\1', l.replace(' ', '_'))
                if obj.Label != l:
                    QtGui.QMessageBox.warning(None, 'Prohibited object label', 'Label fixed: ' +
                        (l.encode('UTF-8') if sys.version_info.major <= 2 else l) + ' -> ' +
                        (obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label),
                        QtGui.QMessageBox.Close)
        self.MeshFrame = MeshFrame(controller = self,
            freecad_objects = self.doc.Objects,
            case_dir_path = os.path.dirname(self.doc.FileName),
            max_cell_size = self.model.sumOfThreeEdgesOfCadObjects(self.doc.Objects)/60.0,
            feature_angle = MyController.FEATURE_ANGLE)
        self.MeshFrame.show()

    def actionOnCaseButton(self):
        dir_name = QtGui.QFileDialog.getExistingDirectory(self.MeshFrame, 'Choose a directory.',
            os.path.expanduser(os.path.join('~', 'Desktop')))
        if dir_name != '':
            self.MeshFrame.caseDirST.setText(dir_name)

    def actionOnOpenButton(self):
        case_dir_path = self.MeshFrame.caseDirST.text()
        if os.path.isdir(case_dir_path):
            os.system("xdg-open '" + case_dir_path + "'")

    def actionOnExportButton(self):
        if not os.path.isdir(self.MeshFrame.caseDirST.text()):
            QtGui.QMessageBox.critical(None, 'Error',
                self.MeshFrame.caseDirST.text() + ' is not a directory.', QtGui.QMessageBox.Close)
            return
        case_dir_path = self.MeshFrame.caseDirST.text()
        # (DEXCS2019を参考に) OpenFOAMのケースフォルダでない場合の処理を追加（2019/9/6）
        if not os.path.isdir(os.path.join(case_dir_path, 'constant')):
            os.system('rsync -a ' + os.path.join(MyController.SOLVER_PATH_TEMPLATE, 'constant') + ' ' +
                case_dir_path + ' --exclude polyMesh')
        if not os.path.isdir(os.path.join(case_dir_path, 'system')):
            os.system('cp -r ' + os.path.join(MyController.SOLVER_PATH_TEMPLATE, 'system') + ' ' + case_dir_path)
        if not os.path.isdir(os.path.join(case_dir_path, '0')):
            os.system('cp -r ' + os.path.join(MyController.SOLVER_PATH_TEMPLATE, '0') + ' ' + case_dir_path)
        triSurface = os.path.join(case_dir_path, 'constant', 'triSurface')
        if os.path.isdir(triSurface):
            shutil.rmtree(triSurface)
        elif os.path.isfile(triSurface):
            os.remove(triSurface)
        os.mkdir(triSurface)
        stl_file_name = os.path.join(triSurface, re.sub('^([0-9])', r'_\1', os.path.basename(case_dir_path)) + '.stl')
        self.model.exportStl(self.doc.Objects, self.MeshFrame.grid, stl_file_name)
        fms_file_name = stl_file_name[:-3] + 'fms'
        cwd = os.getcwd()
        os.chdir(case_dir_path)
        command = ('. ' + MyController.BASHRC_PATH_4_OPENFOAM + ' && ' +
            'surfaceFeatureEdges -angle ' + self.MeshFrame.featureAngleCRL.text() + ' ' +
            stl_file_name + ' ' + fms_file_name)
        if os.system(command) != 0:
            QtGui.QMessageBox.critical(None, 'Error', command + ' was not succeed.', QtGui.QMessageBox.Close)
            os.chdir(cwd)
            return
        os.chdir(cwd)
        self.model.makeMeshDict(case_dir_path = case_dir_path,
            surface_file_name = fms_file_name,
            max_cell_size = self.MeshFrame.maxCellSizeCRL.text(),
            freecad_objects = self.doc.Objects,
            grid = self.MeshFrame.grid,
            feature_angle = self.MeshFrame.featureAngleCRL.text(),
            meshDict = self.meshDict,
            min_cell_size = self.MeshFrame.minCellSizeCRL.text())
        self.model.makeSetFieldsDict(case_dir_path = case_dir_path,
            freecad_objects = self.doc.Objects,
            grid = self.MeshFrame.grid,
            setFieldsDict = self.setFieldsDict)
        self.model.makeTopoSetDict(case_dir_path = case_dir_path,
            freecad_objects = self.doc.Objects,
            grid = self.MeshFrame.grid,
            topoSetDict = self.topoSetDict)
        QtGui.QMessageBox.information(None, 'Done',
            'File system/meshDict for cfMesh has been created.', QtGui.QMessageBox.Close)

    def actionOnCartesianMeshButton(self):
        case_dir_path = self.MeshFrame.caseDirST.text()
        if not os.path.isfile(os.path.join(case_dir_path, 'system', 'meshDict')):
            QtGui.QMessageBox.critical(None, 'No meshDict',
                "File system/meshDict doesn't exist.", QtGui.QMessageBox.Close)
            return
        if QtGui.QMessageBox.question(None, 'cartesianMesh',
            'Really exicute cartesianMesh?',
            QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) == QtGui.QMessageBox.Yes:
            cwd = os.getcwd()
            os.chdir(case_dir_path)
            os.system('gnome-terminal -- bash -c ' + '". ' + MyController.BASHRC_PATH_4_OPENFOAM + ' && ' +
                os.path.join(path_binDEXCS, 'cartesianMeshを実行.py') + '; exec bash"') # exec bashで画面が消えなくなる
            os.chdir(cwd)

    def actionOnImproveMeshQualityButton(self):
        case_dir_path = self.MeshFrame.caseDirST.text()
        if QtGui.QMessageBox.question(None, 'improveMeshQuality',
            'Really exicute improveMeshQuality?',
            QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) == QtGui.QMessageBox.Yes:
            cwd = os.getcwd()
            os.chdir(case_dir_path)
            os.system('gnome-terminal -- bash -c ' + '". ' + MyController.BASHRC_PATH_4_OPENFOAM + ' && ' +
                os.path.join(path_binDEXCS, 'improveMeshQualityを実行.py') + '; exec bash"') # exec bashで画面が消えなくなる
            os.chdir(cwd)

    def actionOnFlattenPatchButton(self):
        case_dir_path = self.MeshFrame.caseDirST.text()
        if QtGui.QMessageBox.question(None, 'Flatten patch',
            'Really flatten patch?',
            QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) == QtGui.QMessageBox.Yes:
            cwd = os.getcwd()
            os.chdir(case_dir_path)
            os.system('gnome-terminal -- bash -c ' + '". ' + MyController.BASHRC_PATH_4_OPENFOAM + ' && ' +
                os.path.join(path_binDEXCS, 'patchを平面に.py') + '; exec bash"') # exec bashで画面が消えなくなる
            os.chdir(cwd)

    def actionOnLoadButton(self):
        case_dir_path = self.MeshFrame.caseDirST.text()
        if not os.path.isdir(case_dir_path):
            return
        try:
            self.meshDict, self.setFieldsDict, self.topoSetDict = self.MeshFrame.setParamsFromDictFiles(
                os.path.join(case_dir_path, 'system', 'meshDict'),
                os.path.join(case_dir_path, 'system', 'setFieldsDict'),
                os.path.join(case_dir_path, 'system', 'topoSetDict'))
        except Exception as e:
            self.meshDict = self.setFieldsDict = self.topoSetDict = None
            QtGui.QMessageBox.critical(None, 'Error', str(e), QtGui.QMessageBox.Close)

    def actionOnEditButton(self):
        meshDict_path = os.path.join(self.MeshFrame.caseDirST.text(), 'system', 'meshDict')
        if not os.path.isfile(meshDict_path):
            QtGui.QMessageBox.critical(None, 'No meshDict',
                "File system/meshDict doesn't exist.", QtGui.QMessageBox.Close)
            return
        if QtGui.QMessageBox.question(None, 'Edit',
            'The file system/meshDict last exported/saved will be edited.\n' +
            'Really edit?', QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) == QtGui.QMessageBox.Yes:
            os.system('gedit ' + meshDict_path)

class MyModel:
    @staticmethod
    def sumOfThreeEdgesOfCadObjects(freecad_objects):
        xmin = ymin = zmin = float('inf')
        xmax = ymax = zmax = float('-inf')
        for obj in freecad_objects:
            try:
                if obj.ViewObject.Visibility and obj.Shape is not None:
                    xmin = min(xmin, obj.Shape.BoundBox.XMin)
                    ymin = min(ymin, obj.Shape.BoundBox.YMin)
                    zmin = min(zmin, obj.Shape.BoundBox.ZMin)
                    xmax = max(xmax, obj.Shape.BoundBox.XMax)
                    ymax = max(ymax, obj.Shape.BoundBox.YMax)
                    zmax = max(zmax, obj.Shape.BoundBox.ZMax)
            except:
                pass
        return xmax - xmin + ymax - ymin + zmax - zmin

    @staticmethod
    def exportStl(freecad_objects, grid, file_name):
        fd, tmp_stl = tempfile.mkstemp(suffix = '.ast')
        os.close(fd)
        os.remove(tmp_stl)
        xmin = ymin = zmin = float('inf')
        xmax = ymax = zmax = float('-inf')
        with open(file_name, 'w') as f:
            for i in grid.table:
                if i[grid.TYPE] in ('BoxRefine', 'CylinderRefine', 'SphereRefine',
                    'BoxSet', 'CylinderSet', 'SphereSet', 'BoxTopo', 'CylinderTopo', 'SphereTopo', 'N/A'):
                    continue
                for obj in freecad_objects:
                    if i[grid.OBJECT_NAME] == (obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label):
                        if i[grid.TYPE] == 'SurfaceRefine':
                            name = os.path.join(os.path.dirname(file_name), i[grid.OBJECT_NAME])
                            Mesh.export([obj], name + '.ast') # ascii format
                            os.rename(name + '.ast', name + '.stl') # can overwrite
                        else:
                            # ascii stlフォーマット
                            # solid 任意の文字列
                            # facet normal x成分値 y成分値 z成分値
                            # outer loop
                            # vertex x成分値 y成分値 z成分値
                            # vertex x成分値 y成分値 z成分値
                            # vertex x成分値 y成分値 z成分値
                            # endloop
                            # endfacet
                            #（facet normal行～endfacet行までを１枚の三角形データとして以降くり返し）
                            # ..............
                            # endsolid 任意の文字列
                            Mesh.export([obj], tmp_stl)
                            for line in open(tmp_stl, 'r'):
                                if 'endsolid' in line:
                                    f.write('endsolid ' + i[grid.OBJECT_NAME] + '\n')
                                elif 'solid' in line:
                                    f.write('solid ' + i[grid.OBJECT_NAME] + '\n')
                                else:
                                    f.write(line)
                                    if line.lstrip().startswith('vertex'):
                                        x, y, z = [float(j) for j in line.split()[1:]]
                                        xmin, ymin, zmin = min(xmin, x), min(ymin, y), min(zmin, z)
                                        xmax, ymax, zmax = max(xmax, x), max(ymax, y), max(zmax, z)
                            os.remove(tmp_stl)
                        break
        return xmin, ymin, zmin, xmax, ymax, zmax

    @staticmethod
    def makeMeshDict(case_dir_path, surface_file_name, max_cell_size, freecad_objects, grid,
        feature_angle, meshDict, min_cell_size):
        dict_name = os.path.join(case_dir_path, 'system', 'meshDict')
        if os.path.isfile(dict_name):
            shutil.copy(dict_name, dict_name + '_bak')
        with open(dict_name, 'w') as f:
            f.write('FoamFile\n{')
            f.write('\n\tversion\t2.0;\n')
            f.write('\tformat\tascii;\n')
            f.write('\tclass\tdictionary;\n')
            f.write('\tlocation\t"system";\n')
            f.write('\tobject\tmeshDict;\n')
            f.write('}\n') # FoamFile
            f.write('\n// A manual is available on\n')
            f.write('// http://cfmesh.com/wp-content/uploads/2015/09/User_Guide-cfMesh_v1.1.pdf\n')
            f.write('\nCUSTOM_OPTIONS\n{\n')
            f.write('\tfeatureAngle\t' + feature_angle + '; // used in surfaceFeatureEdges utility\n')
            f.write('}\n') # CUSTOM_OPTIONS
            f.write('\n// Keep all the cells intersecting the surface template.\n')
            f.write('// Useful in capturing small gaps in a geometry. (default: 0)\n')
            try:
                x = meshDict.getValueForKey(['keepCellsIntersectingBoundary'])
                f.write('keepCellsIntersectingBoundary\t' + x[0] + '; // 1 active or 0 inactive\n')
            except:
                f.write('keepCellsIntersectingBoundary\t1; // 1 active or 0 inactive\n')
            f.write('\n// Remove cells where distinct parts of the mesh are joined together.\n')
            f.write('// Valid only when keepCellsIntersectingBoundary is active. (default: 0)\n')
            try:
                x = meshDict.getValueForKey(['checkForGluedMesh'])
                f.write('checkForGluedMesh\t' + x[0] + '; // 1 active or 0 inactive\n')
            except:
                f.write('checkForGluedMesh\t0; // 1 active or 0 inactive\n')
            f.write('\nmaxCellSize\t' + max_cell_size + '; // (mandatory)\n')
            try:
                x = meshDict.getValueForKey(['boundaryCellSize'])
                f.write('\nboundaryCellSize\t' + x[0] + '; // (optional)\n')
            except:
                f.write('\n// boundaryCellSize\t0.5; // (optional)\n')
            try:
                x = meshDict.getValueForKey(['boundaryCellSizeRefinementThickness'])
                f.write('boundaryCellSizeRefinementThickness\t' + x[0] + '; // (optional)\n')
            except:
                f.write('// boundaryCellSizeRefinementThickness\t5.0; // (optional)\n')
            if min_cell_size != '':
                f.write('\nminCellSize\t' + min_cell_size + '; // (optional)\n')
            else:
                try:
                    min_cell_size = meshDict.getValueForKey(['minCellSize'])[0]
                except:
                    min_cell_size = '1'
                f.write('\n// minCellSize\t' + min_cell_size + '; // (optional)\n')
            f.write('\nsurfaceFile\t"constant/triSurface/' + os.path.basename(surface_file_name) + '"; // (mandatory)\n')
            f.write('\nboundaryLayers\n{')
            f.write('\n\t// Smoothing of boundary layers (default: 0)\n')
            try:
                x = meshDict.getValueForKey(['boundaryLayers', 'optimiseLayer'])
                f.write('\toptimiseLayer\t' + x[0] + '; // 1 active or 0 inactive\n')
            except:
                f.write('\toptimiseLayer\t1; // 1 active or 0 inactive\n')
            try:
                for x in meshDict.getValueForKey(['boundaryLayers']):
                    if DictParserList.isType(x, DictParserList.DICT) and x.key() != 'optimiseLayer':
                        f.write('\n')
                        meshDict.writeContents(x, f, indent = '\t', last_char = '\n')
                        f.write('\n')
            except:
                pass
            f.write('\n\toptimisationParameters\n\t{')
            f.write('\n\t\t// Ratio between the maximum boundary layer thickness and the patch size\n')
            f.write('\t\t// Ued to limit layer thickness in the regions dominated by curvature. (default: 0.3)\n')
            try:
                x = meshDict.getValueForKey(['boundaryLayers', 'optimisationParameters', 'featureSizeFactor'])
                f.write('\t\tfeatureSizeFactor\t' + x[0] + ';\n')
            except:
                f.write('\t\tfeatureSizeFactor\t0.3;\n')
            f.write('\n\t\t// Maximum difference of the layer thickness between two neighboring points\n')
            f.write('\t\t// divided by the distance between the points (optional)\n')
            try:
                x = meshDict.getValueForKey(['boundaryLayers', 'optimisationParameters', 'relThicknessTol'])
                f.write('\t\trelThicknessTol\t' + x[0] + ';\n')
            except:
                f.write('\t\trelThicknessTol\t0.2;\n')
            try:
                for x in meshDict.getValueForKey(['boundaryLayers', 'optimisationParameters']):
                    if (DictParserList.isType(x, DictParserList.DICT) and
                        x.key() not in ['featureSizeFactor', 'relThicknessTol']):
                        f.write('\n')
                        meshDict.writeContents(x, f, indent = '\t\t', last_char = '\n')
                        f.write('\n')
            except:
                pass
            f.write('\t}\n') # optimisationParameters
            f.write('\n\tpatchBoundaryLayers\n\t{')
            for i in grid.table:
                if not i[grid.BOUNDARY_LAYER] or i[grid.TYPE] in (
                    'BoxRefine', 'CylinderRefine', 'SphereRefine', 'SurfaceRefine',
                    'BoxSet', 'CylinderSet', 'SphereSet', 'BoxTopo', 'CylinderTopo', 'SphereTopo', 'N/A'):
                    continue
                f.write('\n\t\t' + i[grid.OBJECT_NAME] + '\n\t\t{')
                f.write('\n\t\t\tnLayers\t{}; // (optional)\n'.format(i[grid.N_LAYERS]))
                f.write('\t\t\tthicknessRatio\t{};\n'.format(i[grid.RATIO]))
                try:
                    x = meshDict.getValueForKey(['boundaryLayers', 'patchBoundaryLayers',
                        i[grid.OBJECT_NAME], 'maxFirstLayerThickness'])
                    f.write('\t\t\tmaxFirstLayerThickness\t' + x[0] + '; // (optional)\n')
                except:
                    f.write('//\t\t\tmaxFirstLayerThickness\t0.5; // (optional)\n')
                try:
                    x = meshDict.getValueForKey(['boundaryLayers', 'patchBoundaryLayers',
                        i[grid.OBJECT_NAME], 'allowDiscontinuity'])
                    f.write('\t\t\tallowDiscontinuity\t' + x[0] + '; // 1 active or 0 inactive\n')
                except:
                    f.write('\t\t\tallowDiscontinuity\t0; // 1 active or 0 inactive\n')
                f.write('\t\t}\n')
            f.write('\t}\n') # patchBoundaryLayers
            f.write('}\n') # boundaryLayers
            f.write('\n// Valid only when keepCellsIntersectingBoundary is not active. (optional)\n')
            f.write('keepCellsIntersectingPatches\n{')
            f.write('\n//\t"patch.*" // accepts regex\n//\t{')
            f.write('\n//\t\tkeepCells\t1; // 1 active or 0 inactive\n')
            f.write('//\t}\n') # "patch.*"
            f.write('}\n') #keepCellsIntersectingPatches
            f.write('\n// Valid only when keepCellsIntersectingBoundary is active. (optional)\n')
            f.write('removeCellsIntersectingPatches\n{')
            f.write('\n//\t"patch.*" // accepts regex\n//\t{')
            f.write('\n//\t\tkeepCells\t0; // 0 remove or 1 keep\n')
            f.write('//\t}\n') # "patch.*"
            f.write('}\n') # removeCellsIntersectingPatches
            f.write('\nlocalRefinement\n{')
            for i in grid.table:
                if i[grid.CELL_SIZE] == '' or i[grid.TYPE] in (
                    'BoxRefine', 'CylinderRefine', 'SphereRefine', 'SurfaceRefine',
                    'BoxSet', 'CylinderSet', 'SphereSet', 'BoxTopo', 'CylinderTopo', 'SphereTopo', 'N/A'):
                    continue
                ref_thickness = i[grid.CELL_SIZE]
                ref_level = 0
                ref_value = float(max_cell_size)/ref_thickness
                while ref_value > 1.0:
                    ref_level += 1
                    ref_value /= 2.0
                f.write('\n\t' + i[grid.OBJECT_NAME] + '\n\t{')
                f.write('\n\t\tcellSize\t{};\n'.format(ref_thickness))
                f.write('//\t\tadditionalRefinementLevels\t{};'.format(ref_level) +
                    ' // Relative to the maximum cell size\n')
                f.write('//\t\trefinementThickness\t{};\n'.format(5*ref_thickness))
                f.write('\t}\n')
            f.write('\n//\t"patch.*" // accepts regex\n//\t{')
            f.write('\n//\t\tcellSize 1;\n')
            f.write('//\t\tadditionalRefinementLevels\t1;\n')
            f.write('//\t\trefinementThickness\t1.2;\n')
            f.write('//\t}\n') # "patch.*"
            f.write('}\n') # localRefinement
            objects = [i[grid.OBJECT_NAME] for i in grid.table]
            f.write('\nobjectRefinements\n{')
            for i in grid.table:
                if i[grid.CELL_SIZE] == '' or i[grid.TYPE] not in ('BoxRefine', 'CylinderRefine', 'SphereRefine'):
                    continue
                ref_thickness = i[grid.CELL_SIZE]
                ref_level = 0
                ref_value = float(max_cell_size)/ref_thickness
                while ref_value > 1.0:
                    ref_level += 1
                    ref_value /= 2.0
                for obj in freecad_objects:
                    if i[grid.OBJECT_NAME] == (obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label):
                        f.write('\n\t' + i[grid.OBJECT_NAME] + '\n\t{\n')
                        if i[grid.TYPE] == 'BoxRefine':
                            f.write('\t\ttype\tbox;\n')
                            f.write('\t\tcellSize\t{};\n'.format(ref_thickness))
                            f.write('//\t\tadditionalRefinementLevels\t{};'.format(ref_level) +
                                ' // Relative to the maximum cell size\n')
                            f.write('\t\tcentre\t({} {} {});\n'.format(obj.Shape.CenterOfMass.x,
                                obj.Shape.CenterOfMass.y, obj.Shape.CenterOfMass.z))
                            f.write('\t\tlengthX\t{};\n'.format(obj.Length.Value))
                            f.write('\t\tlengthY\t{};\n'.format(obj.Width.Value))
                            f.write('\t\tlengthZ\t{};\n'.format(obj.Height.Value))
                        elif i[grid.TYPE] == 'CylinderRefine':
                            f.write('\t\ttype\tcone;\n')
                            f.write('\t\tcellSize\t{};\n'.format(ref_thickness))
                            f.write('//\t\tadditionalRefinementLevels\t{};'.format(ref_level) +
                                ' // Relative to the maximum cell size\n')
                            f.write('\t\tp0\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tp1\t({} {} {});\n'.format(
                                    obj.Placement.Base.x + obj.Placement.Matrix.A13*obj.Height.Value,
                                    obj.Placement.Base.y + obj.Placement.Matrix.A23*obj.Height.Value,
                                    obj.Placement.Base.z + obj.Placement.Matrix.A33*obj.Height.Value))
                            f.write('\t\tradius0\t{};\n'.format(obj.Radius.Value))
                            f.write('\t\tradius1\t{};\n'.format(obj.Radius.Value))
                        elif i[grid.TYPE] == 'SphereRefine':
                            f.write('\t\ttype\tsphere;\n')
                            f.write('\t\tcellSize\t{};\n'.format(ref_thickness))
                            f.write('//\t\tadditionalRefinementLevels\t{};'.format(ref_level) +
                                ' // Relative to the maximum cell size\n')
                            f.write('\t\tcentre\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tradius\t{};\n'.format(obj.Radius.Value))
                            f.write('\t\trefinementThickness\t{};\n'.format(obj.Radius.Value))
                        f.write('\t}\n')
                        break
            try:
                for x in meshDict.getValueForKey(['objectRefinements']):
                    if DictParserList.isType(x, DictParserList.BLOCK) and x.key() not in objects:
                        f.write('\n')
                        meshDict.writeContents(x, f, indent = '\t', last_char = '\n')
                        f.write('\n')
            except:
                pass
            f.write('\n//\tboxExample\n')
            f.write('//\t{\n')
            f.write('//\t\ttype\tbox;\n')
            f.write('//\t\tcellSize\t7.51;\n')
            f.write('//\t\tcentre\t(500 500 150);\n')
            f.write('//\t\tlengthX\t100;\n')
            f.write('//\t\tlengthY\t150;\n')
            f.write('//\t\tlengthZ\t200;\n')
            f.write('//\t}\n')
            f.write('\n//\tconeExample\n')
            f.write('//\t{\n')
            f.write('//\t\ttype\tcone;\n')
            f.write('//\t\tcellSize\t7.51;\n')
            f.write('//\t\tp0\t(-100 1873 -320);\n')
            f.write('//\t\tp1\t(-560 1400 0);\n')
            f.write('//\t\tradius0\t200;\n')
            f.write('//\t\tradius1\t300;\n')
            f.write('//\t}\n')
            f.write('\n//\thollowConeExample\n')
            f.write('//\t{\n')
            f.write('//\t\ttype\thollowCone;\n')
            f.write('//\t\tadditionalRefinementLevels\t2; // Relative to the maximum cell size\n')
            f.write('//\t\tp0\t(-100 1873 -320);\n')
            f.write('//\t\tp1\t(-560 1400 0);\n')
            f.write('//\t\tradius0_Inner\t200;\n')
            f.write('//\t\tradius0_Outer\t300;\n')
            f.write('//\t\tradius1_Inner\t200;\n')
            f.write('//\t\tradius1_Outer\t300;\n')
            f.write('//\t}\n')
            f.write('\n//\tsphereExample\n')
            f.write('//\t{\n')
            f.write('//\t\ttype\tsphere;\n')
            f.write('//\t\tcellSize\t7.51;\n')
            f.write('//\t\tcentre\t(0 700 0);\n')
            f.write('//\t\tradius\t50;\n')
            f.write('//\t\trefinementThickness\t50;\n')
            f.write('//\t}\n')
            f.write('\n//\tlineExample\n')
            f.write('//\t{\n')
            f.write('//\t\ttype\tline;\n')
            f.write('//\t\tcellSize\t7.51;\n')
            f.write('//\t\tp0\t(-750 1000 450);\n')
            f.write('//\t\tp1\t(-750 1500 450);\n')
            f.write('//\t\trefinementThickness\t40;\n')
            f.write('//\t}\n')
            f.write('}\n') # objectRefinements
            f.write('\nsurfaceMeshRefinement\n{')
            for i in grid.table:
                if i[grid.CELL_SIZE] != '' and i[grid.TYPE] == 'SurfaceRefine':
                    ref_thickness = i[grid.CELL_SIZE]
                    ref_level = 0
                    ref_value = float(max_cell_size)/ref_thickness
                    while ref_value > 1.0:
                        ref_level += 1
                        ref_value /= 2.0
                    f.write('\n\t' + i[grid.OBJECT_NAME] + '\n\t{')
                    f.write('\n\t\tsurfaceFile\t"constant/triSurface/' + i[grid.OBJECT_NAME] + '.stl";\n')
                    f.write('\t\tcellSize\t{};\n'.format(ref_thickness))
                    f.write('//\t\tadditionalRefinementLevels\t{};'.format(ref_level) +
                        ' // Relative to the maximum cell size\n')
                    f.write('\t\trefinementThickness\t{};\n'.format(i[grid.RATIO]))
                    f.write('\t}\n')
            try:
                for x in meshDict.getValueForKey(['surfaceMeshRefinement']):
                    if DictParserList.isType(x, DictParserList.BLOCK) and x.key() not in objects:
                        f.write('\n')
                        meshDict.writeContents(x, f, indent = '\t', last_char = '\n')
                        f.write('\n')
            except:
                pass
            f.write('}\n') # surfaceMeshRefinement
            f.write('\nanisotropicSources\n{')
            f.write('\n//\tboxExample\n//\t{')
            f.write('\n//\t\ttype\tbox;\n')
            f.write('//\t\tcentre\t(0 0 0);\n')
            f.write('//\t\tlengthX\t1000;\n')
            f.write('//\t\tlengthY\t1000;\n')
            f.write('//\t\tlengthZ\t200;\n')
            f.write('//\t\tscaleX\t1;\n')
            f.write('//\t\tscaleY\t1;\n')
            f.write('//\t\tscaleZ\t0.3;\n')
            f.write('//\t}\n') # boxExample
            f.write('\n//\tplaneExample\n//\t{')
            f.write('\n//\t\ttype\tplane;\n')
            f.write('//\t\tnormal\t(0 0 1);\n')
            f.write('//\t\torigin\t(0 0 250);\n')
            f.write('//\t\tscalingDistance\t125;\n')
            f.write('//\t\tscalingFactor\t0.5;\n')
            f.write('//\t}\n') # planeExample
            f.write('}\n') # anisotropicSource
            f.write('\nrenameBoundary\n{')
            f.write('\n\tnewPatchNames\n\t{\n')
            for i in grid.table:
                if i[grid.TYPE] not in ('BoxRefine', 'CylinderRefine', 'SphereRefine', 'SurfaceRefine',
                    'BoxSet', 'CylinderSet', 'SphereSet', 'BoxTopo', 'CylinderTopo', 'SphereTopo', 'N/A'):
                    f.write('\t\t' + i[grid.OBJECT_NAME] + '\n\t\t{\n')
                    f.write('\t\t\tnewName\t'+ i[grid.OBJECT_NAME] + ';\n')
                    f.write('\t\t\ttype\t'+ i[grid.TYPE] + ';\n')
                    f.write('\t\t}\n') # i[grid.OBJECT_NAME]
            f.write('\t}\n') # newPatchNames
            f.write('}\n') # renameBoundary
            try:
                for x in meshDict.contents:
                    if (DictParserList.isType(x, (DictParserList.BLOCK, DictParserList.DICT)) and
                        x.key() not in ('FoamFile', 'CUSTOM_OPTIONS', 'keepCellsIntersectingBoundary',
                        'checkForGluedMesh', 'maxCellSize', 'boundaryCellSize',
                        'boundaryCellSizeRefinementThickness', 'minCellSize', 'surfaceFile',
                        'boundaryLayers', 'keepCellsIntersectingPatches', 'removeCellsIntersectingPatches',
                        'localRefinement', 'objectRefinements', 'surfaceMeshRefinement',
                        'anisotropicSources', 'renameBoundary')):
                        f.write('\n')
                        meshDict.writeContents(x, f, indent = '', last_char = '\n')
                        f.write('\n')
            except:
                pass
        os.chmod(dict_name, 0o0666)

    @staticmethod
    def makeSetFieldsDict(case_dir_path, freecad_objects, grid, setFieldsDict):
        has_set = False
        for i in grid.table:
            if i[grid.TYPE] in ('BoxSet', 'CylinderSet', 'SphereSet'):
                has_set = True
                break
        if not has_set:
            return
        dict_name = os.path.join(case_dir_path, 'system', 'setFieldsDict')
        if os.path.isfile(dict_name):
            shutil.copy(dict_name, dict_name + '_bak')
        with open(dict_name, 'w') as f:
            f.write('FoamFile\n{')
            f.write('\n\tversion\t2.0;\n')
            f.write('\tformat\tascii;\n')
            f.write('\tclass\tdictionary;\n')
            f.write('\tlocation\t"system";\n')
            f.write('\tobject\tsetFieldsDict;\n')
            f.write('}\n\n') # FoamFile
            try:
                setFieldsDict.writeContents(setFieldsDict.getDPLForKey(['defaultFieldValues']),
                    f, indent = '', last_char = '\n')
            except:
                f.write('defaultFieldValues // regionsで指定しない領域における値\n(\n')
                f.write('\tvolScalarFieldValue\talpha.water 0 // ←自分の目的に合わせて書き換える\n')
                f.write('\tvolVectorFieldValue\tU ( 0 0 0 ) // ←自分の目的に合わせて書き換える\n);')
            f.write('\n\nregions\n(\n')
            for i in grid.table:
                if i[grid.TYPE] not in ('BoxSet', 'CylinderSet', 'SphereSet'):
                    continue
                for obj in freecad_objects:
                    if i[grid.OBJECT_NAME] == (obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label):
                        if i[grid.TYPE] == 'BoxSet':
                            f.write('\tboxToCell // Object {} in FreeCAD\n'.format(i[grid.OBJECT_NAME]))
                            f.write('\t{\n')
                            f.write('\t\tbox\t({} {} {}) ({} {} {});\n'.format(
                                obj.Shape.BoundBox.XMin, obj.Shape.BoundBox.YMin, obj.Shape.BoundBox.ZMin,
                                obj.Shape.BoundBox.XMax, obj.Shape.BoundBox.YMax, obj.Shape.BoundBox.ZMax))
                        elif i[grid.TYPE] == 'CylinderSet':
                            f.write('\tcylinderToCell // Object {} in FreeCAD\n'.format(i[grid.OBJECT_NAME]))
                            f.write('\t{\n')
                            f.write('\t\tp1\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tp2\t({} {} {});\n'.format(
                                    obj.Placement.Base.x + obj.Placement.Matrix.A13*obj.Height.Value,
                                    obj.Placement.Base.y + obj.Placement.Matrix.A23*obj.Height.Value,
                                    obj.Placement.Base.z + obj.Placement.Matrix.A33*obj.Height.Value))
                            f.write('\t\tradius\t{};\n'.format(obj.Radius.Value))
                        else: # SphereSet
                            f.write('\tsphereToCell // Object {} in FreeCAD'.format(i[grid.OBJECT_NAME]))
                            f.write('\n\t{\n')
                            f.write('\t\tcentre\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tradius\t{};\n'.format(obj.Radius.Value))
                        fieldValues_is_written = False
                        try:
                            for x in setFieldsDict.getValueForKey(['regions']):
                                for y in x.value():
                                    if DictParserList.isType(y, DictParserList.BLOCK) and i[grid.OBJECT_NAME] in y[1]:
                                        for z in y.value():
                                            if DictParserList.isType(z, DictParserList.DICT) and z.key() == 'fieldValues':
                                                setFieldsDict.writeContents(z, f, indent = '\t\t', last_char = '\n')
                                                fieldValues_is_written = True
                                                break
                                        break
                        except:
                            pass
                        if not fieldValues_is_written:
                            f.write('\t\tfieldValues\n\t\t(\n')
                            f.write('\t\t\tvolScalarFieldValue alpha.water 1 // ←自分の目的に合わせて書き換える\n')
                            f.write('\t\t);\n') # fieldValues
                        f.write('\t}\n') # boxToCell, cylinderToCell, sphereToCell
                        break
            try:
                for x in setFieldsDict.getValueForKey(['regions']):
                    for y in x.value():
                        if DictParserList.isType(y, DictParserList.BLOCK) and 'freecad' not in y[1].lower():
                            setFieldsDict.writeContents(y, f, indent = '\t', last_char = '\n')
                            f.write('\n')
            except:
                pass
            f.write(');\n') # regions
            try:
                for x in setFieldsDict.contents:
                    if (DictParserList.isType(x, (DictParserList.BLOCK, DictParserList.DICT)) and
                        x.key() not in ('FoamFile', 'defaultFieldValues', 'regions')):
                        f.write('\n')
                        setFieldsDict.writeContents(x, f, indent = '', last_char = '\n')
                        f.write('\n')
            except:
                pass
        os.chmod(dict_name, 0o0666)

    @staticmethod
    def makeTopoSetDict(case_dir_path, freecad_objects, grid, topoSetDict):
        has_topo = False
        for i in grid.table:
            if i[grid.TYPE] == 'BoxTopo':
                has_topo = True
                break
        if not has_topo:
            return
        dict_name = os.path.join(case_dir_path, 'system', 'topoSetDict')
        if os.path.isfile(dict_name):
            shutil.copy(dict_name, dict_name + '_bak')
        with open(dict_name, 'w') as f:
            f.write('FoamFile\n{')
            f.write('\n\tversion\t2.0;\n')
            f.write('\tformat\tascii;\n')
            f.write('\tclass\tdictionary;\n')
            f.write('\tlocation\t"system";\n')
            f.write('\tobject\ttopoSetDict;\n')
            f.write('}\n') # FoamFile
            f.write('\nactions\n(\n')
            for i in grid.table:
                if i[grid.TYPE] not in ('BoxTopo', 'CylinderTopo', 'SphereTopo'):
                    continue
                for obj in freecad_objects:
                    if i[grid.OBJECT_NAME] == (obj.Label.encode('UTF-8') if sys.version_info.major <= 2 else obj.Label):
                        f.write('\t{' + ' // Object {} in FreeCAD\n'.format(i[grid.OBJECT_NAME]))
                        f.write('\t\tname\t{}CellSet;\n'.format(i[grid.OBJECT_NAME]))
                        f.write('\t\ttype\tcellSet;\n')
                        freecad_object = False
                        action = 'new'
                        try:
                            for x in setFieldsDict.getValueForKey(['actions']):
                                for y in x.value():
                                    if DictParserList.isType(y, DictParserList.BLOCK):
                                        for z in y.value():
                                            if DictParserList.isType(z, DictParserList.DICT):
                                                if z.key() == 'name' and z.value()[0] == i[grid.OBJECT_NAME] + 'CellSet':
                                                    freecad_object = True
                                                elif z.key() == 'action':
                                                    action = z.value()[0]
                                            if freecad_object and action is not None:
                                            break
                        except:
                            pass
                        f.write('\t\taction\t{};\t// new | add | subtract\n'.format(action))
                        if i[grid.TYPE] == 'BoxTopo':
                            f.write('\t\tsource\trotatedBoxToCell;\n')
                            f.write('\t\torigin\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\ti\t({} {} {});\n'.format(
                                    obj.Length.Value*obj.Placement.Matrix.A11, obj.Length.Value*obj.Placement.Matrix.A21,
                                    obj.Length.Value*obj.Placement.Matrix.A31))
                            f.write('\t\tj\t({} {} {});\n'.format(
                                    obj.Width.Value*obj.Placement.Matrix.A12, obj.Width.Value*obj.Placement.Matrix.A22,
                                    obj.Width.Value*obj.Placement.Matrix.A32))
                            f.write('\t\tk\t({} {} {});\n'.format(
                                    obj.Height.Value*obj.Placement.Matrix.A13, obj.Height.Value*obj.Placement.Matrix.A23,
                                    obj.Height.Value*obj.Placement.Matrix.A33))
                        elif i[grid.TYPE] == 'CylinderTopo':
                            f.write('\t\tsource\tcylinderToCell;\n')
                            f.write('\t\tp1\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tp2\t({} {} {});\n'.format(
                                    obj.Placement.Base.x + obj.Placement.Matrix.A13*obj.Height.Value,
                                    obj.Placement.Base.y + obj.Placement.Matrix.A23*obj.Height.Value,
                                    obj.Placement.Base.z + obj.Placement.Matrix.A33*obj.Height.Value))
                            f.write('\t\tradius\t{};\n'.format(obj.Radius.Value))
                        else: # SphereTopo
                            f.write('\t\tsource\tsphereToCell;\n')
                            f.write('\t\torigin\t({} {} {});\n'.format(
                                    obj.Placement.Base.x, obj.Placement.Base.y, obj.Placement.Base.z))
                            f.write('\t\tradius\t{};\n'.format(obj.Radius.Value))
                        f.write('\t}\n')
                        if action == 'new':
                            f.write('\t{' + ' // Object {} in FreeCAD\n'.format(i[grid.OBJECT_NAME]))
                            f.write('\t\tname\t{};\n'.format(i[grid.OBJECT_NAME]))
                            f.write('\t\ttype\tcellZoneSet;\n')
                            f.write('\t\taction\tnew;\n')
                            f.write('\t\tsource\tsetToCellZone;\n')
                            f.write('\t\tset\t{}CellSet;\n'.format(i[grid.OBJECT_NAME]))
                            f.write('\t}\n')
                        break
            try:
                for x in topoSetDict.getValueForKey(['actions']):
                    for y in x.value():
                        freecad_object = False
                        if DictParserList.isType(y, DictParserList.BLOCK):
                            for z in y.value():
                                if DictParserList.isType(z, DictParserList.DICT) and z.key() == 'name':
                                    for i in grid.table:
                                        if z.value()[0] in (i[grid.OBJECT_NAME], i[grid.OBJECT_NAME] + 'CellSet'):
                                            freecad_object = True
                                            break
                                    break
                        if not freecad_object:
                            topoSetDict.writeContents(y, f, indent = '\t', last_char = '\n')
                            f.write('\n')
            except:
                pass
            f.write(');\n') # actions
            try:
                for x in topoSetDict.contents:
                    if (DictParserList.isType(x, (DictParserList.BLOCK, DictParserList.DICT)) and
                        x.key() not in ('FoamFile', 'actions')):
                        f.write('\n')
                        topoSetDict.writeContents(x, f, indent = '', last_char = '\n')
                        f.write('\n')
            except:
                pass
        os.chmod(dict_name, 0o0666)

if __name__ == '__main__':
    MyController()
